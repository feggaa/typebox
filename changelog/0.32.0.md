## [0.32.0](https://www.npmjs.com/package/@sinclair/typebox/v/0.32.0)

## Overview

Revision 0.32.0 carries out a full internal refactor of TypeBox to modularize the Type namespace as well as to enable dual Cjs and Esm publishing support. This revision offers many new additions, including the ability to selectively import Types which can dramatically reduce bundle sizes, it brings three new types (Mapped, Const and Deref) and two new Value functions (Clean and Default). It also carries out many internal optimizations to type inference, and brings TypeBox inline with upcoming revisions of the TypeScript compiler (5.4-dev)

This update has breaking changes and requires a minor revision.

## Contents


- [Modularization](#Modularization)
  - [Type Imports](#Modularization-Type-Imports)
  - [Value Imports](#Modularization-Value-Imports)
- [Types](#Types)
  - [Mapped Type](#Types-Mapped-Type)
  - [Const Type](#Types-Const-Type)
  - [Deref Type](#Types-Deref-Type)
- [Values](#Values)
  - [Clean Function](#Value-Clean-Function)
  - [Default Function](#Value-Default-Function)
- [Optimizations](#Optimizations)
  - [Bundle Size](#Optimizations-Bundle-Size)
- [Breaking](#Breaking)
  - [Value Submodule Imports](#Breaking-Value-Submodule-Imports)
  - [ErrorFunction](#Breaking-ErrorFunction)
  - [RegEx](#Breaking-RegEx)


<a name="Modularization"></a>

## Modularization

Revision 0.32.0 fully modularizes the type system and supports dual publishing of both Esm and Cjs builds of the package. This work was carried out to modernize TypeBox inline with the Esm standard; provide a way for bundlers to optimize TypeBox output via tree shaking and allow the TypeBox type system to continue to scale up. As of this revision, TypeBox now supports selective type imports on top of the classic `Type.*` API.

<a name="Modularization-Type-Imports"></a>

### Type Imports

Revision 0.32.0 adds the ability to selectively import types individually. Selectively importing types can siginficantly reduce the bundle output sizes. 

```typescript
// Revision 0.32.0

import { Type, type Static } from '@sinclair/typebox'           // classic

import { Object, String, Number, ... } from '@sinclair/typebox' // selective
```

<a name="Modularization-Value-Imports"></a>

### Value Imports

Revision 0.32.0 adds the ability to selectively import value operations individually. Selectively importing operations can siginficantly reduce the bundle output sizes. 

```typescript
// Revision 0.31.0

import { Value } from '@sinclair/typebox/value'                // classic

import { Check } from '@sinclair/typebox/value/check'          // classic

// Revision 0.32.0

import { Check, Clone, Cast } from '@sinclair/typebox/value'   // modern
```

<a name="Types"></a>

## Types

Revision 0.32.0 adds three new types to the type system.

<a name="Types-Mapped-Type"></a>

### Mapped Type

Revision 0.32.0 adds a new Type.Mapped type which can be used to express TypeScript [Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html) at runtime. This type is designed to work with Type.Index and Type.Extends, both of which have been updated to support distibutive key mappings through Mapped types. As of this revision, this type is limited to 32 mappable properties (safe upper limit). Optimizations will be explored over the course 0.32.0.

```typescript
const T = Type.Object({                                        // type T = {
  x: Type.Number(),                                            //   x: number,
  y: Type.Number(),                                            //   y: number,
  z: Type.Number()                                             //   z: number,
})                                                             // }

// ... Partial (programmable)

const S = Type.Mapped(                                         // type S = {
  Type.KeyOf(T), (K) =>                                        //   [K in keyof T]?: T[K]
    Type.Optional(Type.Index(T, K))                            // }
)                                           

                                                               // const S = Type.Object({
                                                               //   x: Type.Optional(Type.Number()),
                                                               //   y: Type.Optional(Type.Number()),
                                                               //   z: Type.Optional(Type.Number())
                                                               // })
```

<a name="Types-Const-Type"></a>

### Const Type

Revision 0.32.0 adds the new Type.Const type which will generate a readonly type from JavaScript literal values. This type mirrors TypeScript's `as const` assertion and produces a similar readonly type. As of this revision, the `as const` assertion will be required to use this type. This requirement will likely remain until TypeBox officially drops support for TypeScript 4.0.

```typescript
const A = Type.Const(1 as const)                               // const A: TLiteral<1>

const B = Type.Const([1, 2, 3] as const)                       // const B: TReadonly<TTuple<[
                                                               //   TLiteral<1>,
                                                               //   TLiteral<2>,
                                                               //   TLiteral<3>
                                                               // ]>>

const B = Type.Const({                                         // const C: TObject<{
  x: 1,                                                        //  x: TReadonly<TLiteral<1>>,
  y: 2,                                                        //  y: TReadonly<TLiteral<2>>,
  z: 3                                                         //  z: TReadonly<TLiteral<3>>,
} as const)                                                    // }>                                            
```

<a name="Types-Deref-Type"></a>

### Deref Type

Revision 0.32.0 adds a new Type.Deref type which can be used to dereference types.

```typescript
const Vector = Type.Object({                                   // const Vector = {
  x: Type.Number(),                                            //   type: 'object',
  y: Type.Number(),                                            //   required: ['x', 'y', 'z'],
}, { $id: 'Vector' })                                          //   properties: {
                                                               //     x: { type: 'number' },
                                                               //     y: { type: 'number' }
                                                               //   },
                                                               //   $id: 'Vector'
                                                               // }

const VectorRef = Type.Ref(Vector)                             // const VectorRef = {
                                                               //   $ref: 'Vector'
                                                               // }
// ... Embedded Reference Type

const Vertex = Type.Object({                                   // const Vertex = {
  position: VectorRef,                                         //   type: 'object',
  texcoord: VectorRef,                                         //   required: ['position', 'texcoord'],
})                                                             //   properties: {
                                                               //     position: { $ref: 'Vector' },
                                                               //     texcoord: { $ref: 'Vector' }
                                                               //   }
                                                               // }

// ... Dereferenced Embedded Reference Type

const VertexDeref = Type.Deref(Vertex, [Vector])               // const VertexDeref = {
                                                               //   type: 'object',
                                                               //   required: ['position', 'texcoord'],
                                                               //   properties: {
                                                               //     position: {
                                                               //       type: 'object',
                                                               //       required: ['x', 'y', 'z'],
                                                               //       properties: {
                                                               //         x: { type: 'number' },
                                                               //         y: { type: 'number' }
                                                               //       }
                                                               //     },
                                                               //     texcoord: {
                                                               //       type: 'object',
                                                               //       required: ['x', 'y', 'z'],
                                                               //       properties: {
                                                               //         x: { type: 'number' },
                                                               //         y: { type: 'number' }
                                                               //       }
                                                               //     }
                                                               //   }
                                                               // }
```

<a name="Values"></a>

## Values

Revision 0.32.0 adds two new functions to the Value module.

<a name="Values-Clean-Function"></a>

### Clean Function

Revision 0.32.0 adds a new Clean function that can be used to omit any values unknown to the type. This function will work irrespective of if `additionalProperties` is specified on the type. The Clean function is intended to mirror the functionality of Ajv's `removeAdditional` configuration.

```typescript
const T = Type.Object({ 
  x: Type.Number(), 
  y: Type.Number() 
})

const X = Value.Clean(T, null)                                  // const 'X = null

const Y = Value.Clean(T, { x: 1 })                              // const 'Y = { x: 1 }

const Z = Value.Clean(T, { x: 1, y: 2, z: 3 })                  // const 'Z = { x: 1, y: 2 }
```

Note: the Clean function does not check the validity of the value being cleaned, and does not provided assurances that the result will be valid. Its return type is `unknown` and should checked before use.

<a name="Values-Default-Function"></a>

### Default Function

Revision 0.32.0 adds a new Default function that can be used to add missing values if the type specifies a `default` annotation. This function is used to mirror Ajv's `useDefaults` functionality.

```typescript
const T = Type.Object({ 
  x: Type.Number({ default: 0 }), 
  y: Type.Number({ default: 0 })
})

const X = Value.Default(T, null)                               // const 'X = null - non-enumerable

const Y = Value.Default(T, { })                                // const 'Y = { x: 0, y: 0 }

const Z = Value.Default(T, { x: 1 })                           // const 'Z = { x: 1, y: 0 }
```

The Default function does not check the validity of the value being defaulted, and does not provided assurances that the result will be valid. Its return type is `unknown` and should checked before use.

<a name="Optimizations"></a>

## Optimizations

Due to the work to modularize the type system, additional bundle optimizations have since become possible. Revision 0.32.0 updates all internal imports to import only dependent types and functionality. The following shows the comparisons between 0.31.0 and 0.32.0.

<a name="Optimizations-Bundle-Size"></a>

```typescript
// Revision 0.31.0

┌──────────────────────┬────────────┬────────────┬─────────────┐
│       (index)        │  Compiled  │  Minified  │ Compression │
├──────────────────────┼────────────┼────────────┼─────────────┤
│ typebox/compiler     │ '163.6 kb' │ ' 71.6 kb' │  '2.28 x'   │
│ typebox/errors       │ '113.3 kb' │ ' 50.1 kb' │  '2.26 x'   │
│ typebox/system       │ ' 83.9 kb' │ ' 37.5 kb' │  '2.24 x'   │
│ typebox/value        │ '191.1 kb' │ ' 82.3 kb' │  '2.32 x'   │
│ typebox              │ ' 73.8 kb' │ ' 32.3 kb' │  '2.29 x'   │
└──────────────────────┴────────────┴────────────┴─────────────┘

//  Revision 0.32.0

┌──────────────────────┬────────────┬────────────┬─────────────┐
│       (index)        │  Compiled  │  Minified  │ Compression │
├──────────────────────┼────────────┼────────────┼─────────────┤
│ typebox/compiler     │ '109.2 kb' │ ' 48.6 kb' │  '2.25 x'   │
│ typebox/errors       │ ' 55.0 kb' │ ' 25.1 kb' │  '2.19 x'   │
│ typebox/system       │ '  4.6 kb' │ '  2.0 kb' │  '2.31 x'   │
│ typebox/type         │ ' 81.7 kb' │ ' 34.4 kb' │  '2.37 x'   │
│ typebox/value        │ '144.2 kb' │ ' 61.5 kb' │  '2.34 x'   │
│ typebox              │ ' 81.7 kb' │ ' 34.4 kb' │  '2.37 x'   │
└──────────────────────┴────────────┴────────────┴─────────────┘
```

<a name="Breaking"></a>

## Breaking

The following list the breaking changes in Revision 0.32.0.

<a name="Breaking-Value-Submodule-Imports"></a>

### Value Submodule Imports

The value submodule imports are unfortunately no longer supported. Instead, these can be imported directly on the `/value` path. The need to break the submodule value paths was mostly due complexities configuring dual Esm and Cjs publishing for the package, as well as retaining support for pre and post node16 module resolution (of which many complexities exist, both for Node as well as for TypeScript type module resolution)

```typescript
// Revision 0.31.0

import { Check } from '@sinclair/typebox/value/check'

// Revision 0.32.0

import { Check } from '@sinclair/typebox/value'
```

<a name="Breaking-ErrorFunction"></a>

### ErrorFunction

The TypeSystemErrorFunction has been removed, and replaced with SetErrorFunction which can be imported on the `/errors` submodule. This change is generally a tidy up, and to reserve the `/system` module specifically for type system policy configuration.

```typescript
// Revision 0.31.0

import { TypeSystemErrorFunction, ValueErrorType, DefaultErrorFunction } from '@sinclair/typebox/system'

TypeSystemErrorFunction.Set((schema, errorType) => { // i18n override
  switch(errorType) {
    /* en-US */ case ValueErrorType.String: return 'Expected string'
    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  
    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      
    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          
  }
})

// Revision 0.32.0

import { SetErrorFunction, ValueErrorType, DefaultErrorFunction } from '@sinclair/typebox/errors'

SetErrorFunction((schema, errorType) => { // i18n override
  switch(errorType) {
    /* en-US */ case ValueErrorType.String: return 'Expected string'
    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  
    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      
    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          
  }
})
```

<a name="Breaking-RegEx"></a>

### RegEx

This RegEx function was flagged for deprecation on 0.30.0. It has been removed on 0.32.0. Use the Type.RegExp type, or Type.String with a pattern.

```typescript
// Revision 0.31.0

const T = Type.RegEx(/abc/)                                    // deprecation warning

// Revision 0.32.0

const B = Type.RegExp(/abc/)                                   // Extended Type

const T = Type.String({ pattern: /abc/.source })               // Standard Type
```